# This is the final code of security.

from datetime import datetime, timedelta, timezone
from typing import Union

import jwt
from fastapi import Depends, FastAPI, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jwt.exceptions import InvalidTokenError
from passlib.context import CryptContext
from pydantic import BaseModel

# This SECRET_KEY is generated by "openssl rand -hex 32"
SECRET_KEY = "3a2d452c2798a0ff89341f32893f199a49717b2e4bab6deb236c6fd8b6a3d1ab"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30

# This user db is fake, not actual one, only for practice
fake_users_db = {
    "johndoe": {
        "username": "johndoe",
        "full_name": "John Doe",
        "email": "johndoe@example.com",
        # This is hard corded
        "hashed_password": "$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW",
        "disabled": False,
    }
}

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Union[str, None] = None

class User(BaseModel):
    username: str
    email: Union[str, None] = None
    fullname: Union[str, None] = None
    disabled: Union[bool, None] = None

class UserInDB(User):
    hashed_password: str

# For encrypt the token
pwd_context = CryptContext(schemes=["bcrypt"], deprecated = "auto")

# For the client to know where to send the request to get access key
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")
app = FastAPI()

# The roll is the name
# This is for authenticate_user
def verify_password(raw, hashed):
    # This checks whether raw and hashed password are mached
    return pwd_context.verify(raw, hashed)

# Hash the password
def get_password_hash(pwd):
    return pwd_context.hash(pwd)

# This is for authenticate_user
# Just return the User data in UserInDB format
def get_user(db, username: str):
    if username in db:
        user_dict = db[username]
        return UserInDB(**user_dict)
    
def authenticate_user(fake_db, username: str, pwd: str):
    user = get_user(fake_db, username)
    if not user:
        return False
    if not verify_password(pwd, user.hashed_password):
        return False
    return user

# Timedelta is jsut for time, allowing to calculate time
def create_access_token(data: dict, expires_delta: Union[timedelta, None] = None):
    # This operation is just for in case
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc)+expires_delta
    # We could not add time without using timedelta
    else:
        expire = datetime.now(timezone.utc)+timedelta(minutes=15)

    to_encode.update({"exp": expire})
    encode_jwt  = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encode_jwt

# Get the user info from token
async def get_current_user(token: str = Depends(oauth2_scheme)):
    credentials_exception = HTTPException(
        status_code = status.HTTP_401_UNAUTHORIZED,
        detail = "ERROROOOOO",
        headers = {"WWW,,,", "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    
    except InvalidTokenError:
        raise credentials_exception
    user = get_user(fake_users_db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)):
    if current_user.disabled:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

@app.post("/token")
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
) -> Token:
    user = authenticate_user(fake_users_db, form_data.username, form_data.password)
    if not user: 
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail ="Incorrect username or password",
            headers ={"HSSS": "SS"}
        )

    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )    
    return Token(access_token=access_token, token_type="breaer")

# This part is just practice
# In the real app, it returns the actual data of user like user name, pw, or 
# something like that
@app.get("/user/me/", response_model=User)
async def read_user_me(
    current_user: User=Depends(get_current_active_user)
):
    return current_user

# the same as above, it returns the item of user
# In this case, this is just for practice, so it returns just damy items
@app.get("/users/me/items/")
async def read_own_items(current_user: User = Depends(get_current_active_user)):
    return [{"item_id": "Foo", "owner": current_user.username}]